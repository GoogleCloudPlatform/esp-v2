package routegen

import (
	"fmt"
	"strings"

	"github.com/GoogleCloudPlatform/esp-v2/src/go/configgenerator/clustergen"
	"github.com/GoogleCloudPlatform/esp-v2/src/go/configgenerator/filtergen"
	"github.com/GoogleCloudPlatform/esp-v2/src/go/configgenerator/routegen/helpers"
	"github.com/GoogleCloudPlatform/esp-v2/src/go/options"
	"github.com/GoogleCloudPlatform/esp-v2/src/go/util"
	"github.com/GoogleCloudPlatform/esp-v2/src/go/util/httppattern"
	routepb "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
	"github.com/golang/glog"
	servicepb "google.golang.org/genproto/googleapis/api/serviceconfig"
)

// DirectResponseHealthCheckGenerator is a RouteGenerator that creates routes
// for Envoy health checks.
type DirectResponseHealthCheckGenerator struct {
	AutogeneratedOperationPrefix string
	ESPOperationAPI              string
	HTTPPattern                  *httppattern.Pattern

	// Technically these health checks should be handled directly by Envoy and never
	// reach the backend. However, the routes configs must contain the backend
	// cluster info in order for health check to be preformed.
	LocalBackendClusterName string
	BackendRouteGen         *helpers.BackendRouteGenerator

	*NoopRouteGenerator
}

// NewDirectResponseHealthCheckRouteGenFromOPConfig creates DirectResponseHealthCheckGenerator
// from OP service config + ESPv2 options.
// It is a RouteGeneratorOPFactory.
func NewDirectResponseHealthCheckRouteGenFromOPConfig(serviceConfig *servicepb.Service, opts options.ConfigGeneratorOptions) (RouteGenerator, error) {
	if opts.Healthz == "" {
		glog.Info("Not adding health check filter gen because healthz path is not specified.")
		return nil, nil
	}

	healthzPath := opts.Healthz
	if !strings.HasPrefix(healthzPath, "/") {
		healthzPath = fmt.Sprintf("/%s", healthzPath)
	}

	uriTemplate, err := httppattern.ParseUriTemplate(healthzPath)
	if err != nil {
		return nil, err
	}

	httpRule := &httppattern.Pattern{
		HttpMethod:  util.GET,
		UriTemplate: uriTemplate,
	}

	return &DirectResponseHealthCheckGenerator{
		AutogeneratedOperationPrefix: opts.HealthCheckAutogeneratedOperationPrefix,
		ESPOperationAPI:              opts.HealthCheckOperation,
		HTTPPattern:                  httpRule,
		// Health check is always against local cluster.
		// Remote clusters are not supported.
		LocalBackendClusterName: clustergen.MakeLocalBackendClusterName(serviceConfig),
		BackendRouteGen:         helpers.NewBackendRouteGeneratorFromOPConfig(opts),
	}, nil
}

// RouteType implements interface RouteGenerator.
func (g *DirectResponseHealthCheckGenerator) RouteType() string {
	return "healthz_routes"
}

// GenRouteConfig implements interface RouteGenerator.
//
// Forked from `service_info.go: processHttpRule()`.
func (g *DirectResponseHealthCheckGenerator) GenRouteConfig(filterGens []filtergen.FilterGenerator) ([]*routepb.Route, error) {
	methodCfg := &helpers.MethodCfg{
		OperationName:      formOperationName(g.ESPOperationAPI, g.AutogeneratedOperationPrefix),
		BackendClusterName: g.LocalBackendClusterName,
		Deadline:           util.DefaultResponseDeadline,
		HTTPPattern:        g.HTTPPattern,
	}

	return g.BackendRouteGen.GenRoutesForMethod(methodCfg, filterGens)
}

// AffectedHTTPPatterns implements interface RouteGenerator.
func (g *DirectResponseHealthCheckGenerator) AffectedHTTPPatterns() httppattern.MethodSlice {
	return httppattern.MethodSlice{
		{
			Pattern:   g.HTTPPattern,
			Operation: formOperationName(g.ESPOperationAPI, g.AutogeneratedOperationPrefix),
		},
	}
}

func formOperationName(espOperationAPI string, autogeneratedOperationPrefix string) string {
	return fmt.Sprintf("%s.%s_HealthCheck", espOperationAPI, autogeneratedOperationPrefix)
}
